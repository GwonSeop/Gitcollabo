1. input된 맵에 관한 값을 split()을 통하여 (n,m)리스트 형태로 x값에 저장
[['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
['#', '.', 'O', '.', '.', '.', '.', 'R', 'B', '#'],
['#', '#', '#', '#', '#', '#', '#', '#', '#', '#']] << 형태

2. 파란구슬(B) 위치와 빨간구슬(R)의 위치 인덱스 값을 저장
3. cnt << 실행 횟수  , p << 방향 설정에 대한 값
4. R 의 위치인덱스 B의 위치인덱스가 O 와 같으면 Fail 출력 ( R위치, B위치까지)
5. R 의 위치인덱스가 O 이면 실행횟수 출력 (R위치, B위치 출력)
6. B 의 위치인덱스가 O 이면 Fail 출력
7. cnt 횟수가 10 이상일때 -1 출력
8. R의 위치에서 왼쪽으로 1칸이동한 값이 #이 아니고 p 값이 0(처음실행값) 이거나 2(전 실행이 오른쪽으로 이동한 값)가 아닐때
   p=1로 설정 ( 왼쪽으로 이동 실행을 했다는 기록 ) try를 통해 R위치의 왼쪽끝 #에 닿는 위치 인덱스를 R값으로 설정, 중간에 O값이 나오면 빠져나오도록 함 
   이때 B값도 같은 방향으로 움직이 돼 O값에 들어가면 실행종료
9. 위의 방법으로 네가지 방향 같은 알고리즘 ( 이전에 실행한 반대 방향으로 가지 않음 )
10. 중간에 갈랫길을 만나면 두 방향으로 출발하는 경우의 cnt 값중 최솟값을 더함 만약 두 경우 모두 길이 존재하지않으면 10이상의 값을 출력하여 실패판정 유도
+ 11 . 만약 첫 실행 가능 방향이 두가지 이상일때를 고려하여 for문을 이용 후 최솟값으로 출력